package simulation

// Represents the state of a cell in the board.
// A board cell can either be:
// * Empty.
// * Marked by X.
// * Marked by O.
type CellMark = int

const (
	EMPTY CellMark = iota
	O
	X
)

// 3x3 board represented by a 1D array.
// Indices on the array:
// |0|1|2|
// |3|4|5|
// |6|7|8|
type TicTacToeBoard = []CellMark

// The first 9 bits are p1
// The second 9 bits are p2
// Each bit is 1 if the cell is marked by that player
func ToBitMasks(b *TicTacToeBoard) int {
	board := 0

	for i, v := range *b {
		if v == X {
			board |= 1 << i
		} else if v == O {
			board |= 1 << (i + 9)
		}
	}

	return board
}

// Regenerates a board from a bitmask generated by `ToBitMasks`
func BoardFromBitMask(mask int) TicTacToeBoard {
	board := make([]CellMark, 0, 9)

	for i := range 9 {
		if mask&(1<<i) == 1 {
			board[i] = X
		}
	}

	for i := 9; i < 9*2; i++ {
		if mask&(1<<i) == 1 {
			board[i] = O
		}
	}

	return board
}

// idx must be a number betwen 0-8!
// This function makes the necessary padding to mark it on the corresponding bit
// Returns the bitmask of the new board
func CopyAndMark(mask int, mark CellMark, idx int) int {
	if mark == X {
		return mask | (1 << idx)
	} else if mark == O {
		return mask | (1<<idx + 9)
	} else {
		panic("You can't mark a cell as empty!")
	}
}
