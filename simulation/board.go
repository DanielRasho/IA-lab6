package simulation

import "strconv"

// Represents the state of a cell in the board.
// A board cell can either be:
// * Empty.
// * Marked by X.
// * Marked by O.
type CellMark = int

const (
	EMPTY CellMark = iota
	X
	O
)

func CellToString(c CellMark, idx int64) string {
	switch c {
	case EMPTY:
		return strconv.FormatInt(idx, 10)
	case O:
		return "O"
	case X:
		return "X"
	default:
		panic("Can't convert invalid cellmark to string!")
	}
}

// 3x3 board represented by a 1D array.
// Indices on the array:
// |0|1|2|
// |3|4|5|
// |6|7|8|
type TicTacToeBoard = []CellMark

// The first 9 bits are p1
// The second 9 bits are p2
// Each bit is 1 if the cell is marked by that player
func ToBitMasks(b *TicTacToeBoard) int {
	board := 0

	for i, v := range *b {
		if v == X {
			board |= 1 << i
		} else if v == O {
			board |= 1 << (i + 9)
		}
	}

	return board
}

// Regenerates a board from a bitmask generated by `ToBitMasks`
func BoardFromBitMask(mask int) TicTacToeBoard {
	board := make([]CellMark, 9)
	// 100010010000101101
	// 100010010001101101

	for i := range 9 {
		if mask&(1<<i) > 0 {
			board[i] = X
		}
	}

	for i := 9; i < 9*2; i++ {
		if mask&(1<<i) > 0 {
			board[i%9] = O
		}
	}

	return board
}

// idx must be a number betwen 0-8!
// This function makes the necessary padding to mark it on the corresponding bit
// Returns the bitmask of the new board
func CopyAndMark(mask int, mark CellMark, idx int) int {
	if mark == X {
		bitShift := 1 << idx
		return mask | bitShift
	} else if mark == O {
		bitShift := 1 << (idx + 9)
		return mask | bitShift
	} else {
		panic("You can't mark a cell as empty!")
	}
}

// Returns the winner if there is one on the passed board
func GetBoardWinner(mask int) *Turn {
	board := BoardFromBitMask(mask)
	playersToCheck := []Turn{P1, P2}

	for _, currentPlayer := range playersToCheck {
		if PlayerWonInBoard(&board, currentPlayer) {
			return &currentPlayer
		}
	}

	return nil
}

// Given a board finds the
func GetAvailableCells(board TicTacToeBoard) []int {
	available := make([]int, 0, 9)

	for i, mark := range board {
		if mark != EMPTY {
			continue
		}
		available = append(available, i)
	}
	return available
}
